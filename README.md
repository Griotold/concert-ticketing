# 프로젝트 개요

특정 일시에 정원이 N명인 콘서트의 좌석을 예약할 수 있는 서비스를 개발하는 것을 목표로 합니다.

## 주요 목표

- 공정한 예매 기회 제공: 대기열 시스템을 통해 모든 사용자에게 동등한 기회를 제공합니다.
- 동시성 문제 해결: 같은 좌석에 대한 중복 예매를 방지하고, 안정적인 거래를 보장합니다.
- 분산 환경 지원: 다수의 인스턴스로 애플리케이션이 동작하더라도 기능에 문제가 없도록 합니다.
- 사용자 경험 개선: 실시간 정보 제공으로 사용자 만족도를 높입니다.

### 대기열 관리 시스템

- 사용자별 대기열 토큰 발급
- 대기 순서 및 잔여 시간 정보 제공
- 폴링 방식을 통한 대기열 상태 확인
- 요청 순서에 따른 정확한 대기열 관리

### 잔액 관리 시스템

- 사용자 잔액 충전 및 조회 기능
- 좌석 예약 시 충전된 잔액 사용

### 좌석 점유 시스템

- 일정 시간 동안의 좌석 점유 기능
- 점유 시간 동안 다른 사용자의 접근 제한
- 점유 시간 초과 시 자동 해제 기능
- 점유 시간은 정책에 따라 변경 가능

### 예약 시스템

- 콘서트 예약 가능 날짜 조회
- 특정 날짜의 예약 가능 좌석 목록 조회
- 좌석 번호 부여 (1번부터 50번까지)
- 특정 날짜와 좌석 번호로 예약 기능

### 결제 시스템

- 결제 완료 시 결제 내역 생성
- 결제 완료 시 좌석 예약 확정
- 결제 완료 또는 예약 활동 종료 시 대기열에서 제거

# ERD
![image](https://github.com/user-attachments/assets/302c79cb-fa03-4159-8ba1-0205510fbd9f)

# 기술 스택

## 백엔드

- 언어: Kotlin
- 프레임워크: Spring Boot
- 빌드 도구: Gradle

## 데이터베이스

- RDBMS: MySQL 8.0
- ORM: Spring Data JPA

Spring Data JPA를 사용하여 객체-관계 매핑을 구현하였으며, 이를 통해 데이터베이스 조작을 더욱 객체지향적으로 수행할 수 있었습니다.

## 캐싱

- 인메모리 데이터 저장소: Redis

Redis 를 사용하여 대기열 관리, 분산 락 구현, 그리고 자주 접근되는 데이터의 캐싱을 구현했습니다. 이를 통해 시스템의 응답 시간을 크게 개선하고, 데이터베이스의 부하를 줄일 수 있었습니다.

## 동시성 제어

- 분산 락: Redisson 을 이용한, Pub/Sub 구조의 분산락 구현
- 데이터베이스 락: Pessimistic Lock, Optimistic Lock 활용

동시성 문제를 해결하기 위해 Redis 기반의 분산 락과 데이터베이스 수준의 락을 병행하여 사용했습니다. 이를 통해 분산 환경에서도 데이터 일관성을 유지하고 동시성 이슈를 효과적으로 관리할 수 있었습니다.

## 테스트

다양한 레벨의 테스트를 구현하여 시스템의 안정성과 신뢰성을 확보했습니다. 특히 k6를 이용한 부하 테스트를 통해 대규모 트래픽 상황에서의 시스템 성능을 검증했습니다.

- 단위 테스트: JUnit 5, Mockito
- 통합 테스트: Spring Boot Test

## 주요 설계 특징

- **의존성 역전 원칙 (DIP) 적용**
    - Domain 계층은 외부 계층에 의존하지 않으며, Application 계층을 통해 Infrastructure 계층과 소통합니다.
- **유스케이스 중심 설계**
    - 각 비즈니스 기능은 별도의 UseCase로 정의되어 있어, 단일 책임 원칙을 준수합니다.
# 주요 기술적 도전과 해결 방안

## 대규모 트래픽 처리

### 도전 과제

콘서트 티켓 예매 시스템의 특성상, 티켓 오픈 시 짧은 시간 동안 대량의 트래픽이 집중됩니다. 이러한 상황에서 시스템의 안정성과 성능을 유지하는 것이 큰 도전이었습니다.

### 해결 방안

**대기열 시스템 구현**

- Redis의 Sorted Set을 활용하여 효율적인 대기열 관리 시스템을 구현했습니다.
- 대기 큐와 활성 큐를 분리하여 관리하고, 토큰의 TTL을 추적합니다.
- 사용자에게 대기열 토큰을 발급하고, 순차적으로 예매 과정을 진행하도록 했습니다.
- 10초마다 1,400개의 토큰을 활성 큐로 이동시키는 전략을 채택했습니다.
- 대기열의 상태를 실시간으로 제공하여 사용자 경험을 개선했습니다.

**캐싱 전략**

- Redis를 이용해 자주 조회되는 데이터(콘서트 정보)를 캐싱하여 데이터베이스 부하를 줄이고 응답 시간을 개선했습니다.
- 캐싱 적용 결과, 콘서트 목록 조회 API의 응답 시간이 401ms에서 43.3ms로 약 89% 개선되었습니다.
- 콘서트 이벤트 조회 API도 64.8ms에서 54.9ms로 약 15% 개선되었습니다.

## 동시성 제어

### 도전 과제

여러 사용자가 동시에 같은 좌석을 예매하려 할 때, 그리고 동시에 지갑 잔액을 충전하거나 사용할 때 발생할 수 있는 동시성 문제를 해결해야 했습니다.

**분산 락(Distributed Lock)과 비관적 락(Pessimistic Lock) 조합**

- Redis를 이용한 분산 락과 데이터베이스의 비관적 락을 조합하여 사용했습니다.
- 이 방식은 다른 접근법(비관적 락만 사용, 낙관적 락 사용)에 비해 성능이 우수했습니다.
- 특히 사용자 수가 증가할수록 이 방식의 성능 우위가 두드러졌습니다.

**성능 테스트 결과**

- 5,000명의 동시 사용자 테스트에서:
    - 분산 락 + 비관적 락: 1,825.0ms
    - 비관적 락만 사용: 4,382.3ms
    - 낙관적 락 사용: 3,264.0ms

**지갑 잔액 관리**

- 분산 락을 사용하여 동시에 발생하는 충전과 사용 요청을 순차적으로 처리했습니다.
- 이를 통해 잔액의 정확성을 보장하고 동시성 문제를 해결했습니다.

## 성능 최적화

### 캐싱 전략

Redis 를 활용하여 자주 접근되는 데이터를 캐싱함으로써 데이터베이스 부하를 줄이고 응답 시간을 개선했습니다.

- 콘서트 조회 API 캐싱
    - 콘서트 정보는 자주 변경되지 않는 특성을 활용
    - 캐싱 적용 결과, 응답 시간이 401ms에서 43.3ms로 약 89% 개선
- 콘서트 이벤트 조회 API 캐싱
    - 예약 가능한 날짜 정보를 캐싱
    - 응답 시간이 64.8ms에서 54.9ms로 약 15% 개선
- 캐싱 제외 항목
    - 실시간성이 중요한 데이터(예: 좌석 가용성, 결제 정보)는 캐싱에서 제외

**캐싱 적용 결과**

- 전체 시스템의 처리량이 초당 2.73 요청에서 4.41 요청으로 61.41% 증가
- 평균 응답 시간이 47.36ms에서 55.43ms로 소폭 증가했지만, 이는 처리량 증가로 인한 것으로 판단됩니다.

### 데이터베이스 인덱싱 

데이터베이스 쿼리 성능을 개선하기 위해 적절한 인덱스를 설계하고 적용했습니다.

- 콘서트 이벤트 테이블 인덱싱
    - `(concert_id, reservation_start_at DESC, reservation_end_at DESC)` 복합 인덱스 적용
    - 대규모 데이터셋(200만 개의 콘서트 이벤트)에서 쿼리 실행 시간을 0.09ms 수준으로 유지
- 좌석 테이블 인덱싱
    - `(concert_event_id DESC, is_available)` 복합 인덱스 적용
    - 1000만 개의 좌석 데이터에서 쿼리 실행 시간을 0.07ms 수준으로 개선

**인덱싱 적용 결과**

- 콘서트 이벤트 조회 쿼리의 실행 시간을 378.8ms에서 0.09ms로 대폭 개선
- 좌석 조회 쿼리의 실행 시간을 1064.14ms에서 0.07ms로 획기적으로 개선
